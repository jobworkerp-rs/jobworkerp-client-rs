use anyhow::Result;

pub trait PluginRunner: Send + Sync {
    fn name(&self) -> String;
    fn description(&self) -> String;
    fn load(&mut self, settings: Vec<u8>) -> Result<()>;
    fn run(&mut self, args: Vec<u8>) -> Result<Vec<Vec<u8>>>;
    // run for generating stream
    fn begin_stream(&mut self, args: Vec<u8>) -> Result<()> {
        // default implementation (return empty)
        let _ = args;
        Err(anyhow::anyhow!("not implemented"))
    }
    // receive stream generated by run_stream()
    fn receive_stream(&mut self) -> Result<Option<Vec<u8>>> {
        // default implementation (return empty)
        Err(anyhow::anyhow!("not implemented"))
    }
    fn cancel(&mut self) -> bool;
    fn is_canceled(&self) -> bool;
    fn runner_settings_proto(&self) -> String;
    fn job_args_proto(&self) -> String;
    fn result_output_proto(&self) -> Option<String>;
    fn output_type(&self) -> crate::jobworkerp::data::StreamingOutputType {
        crate::jobworkerp::data::StreamingOutputType::NonStreaming
    }
    fn settings_schema(&self) -> String {
        let schema = schemars::schema_for!(crate::jobworkerp::data::Empty);
        match serde_json::to_string(&schema) {
            Ok(s) => s,
            Err(e) => {
                tracing::error!("error in settings_schema: {:?}", e);
                "".to_string()
            }
        }
    }
    fn arguments_schema(&self) -> String {
        let schema = schemars::schema_for!(crate::jobworkerp::data::Empty);
        match serde_json::to_string(&schema) {
            Ok(s) => s,
            Err(e) => {
                tracing::error!("error in arguments_schema: {:?}", e);
                "".to_string()
            }
        }
    }
    fn output_json_schema(&self) -> Option<String> {
        None
    }
}
