use anyhow::Result;
use std::collections::HashMap;

/// Type alias for the collect_stream return type to reduce complexity
pub type CollectStreamFuture = std::pin::Pin<
    Box<dyn std::future::Future<Output = Result<(Vec<u8>, HashMap<String, String>)>> + Send>,
>;

/// Legacy PluginRunner trait (origin/main compatible)
///
/// This trait maintains binary compatibility with plugins compiled against origin/main.
/// DO NOT modify this trait definition - it will break existing plugin binaries!
pub trait PluginRunner: Send + Sync {
    fn name(&self) -> String;
    fn description(&self) -> String;
    fn load(&mut self, settings: Vec<u8>) -> Result<()>;
    fn run(
        &mut self,
        args: Vec<u8>,
        metadata: HashMap<String, String>,
    ) -> (Result<Vec<u8>>, HashMap<String, String>);
    // run for generating stream
    fn begin_stream(&mut self, arg: Vec<u8>, metadata: HashMap<String, String>) -> Result<()> {
        // default implementation (return empty)
        let (_, _) = (arg, metadata);
        Err(anyhow::anyhow!("not implemented"))
    }
    // receive stream generated by run_stream()
    fn receive_stream(&mut self) -> Result<Option<Vec<u8>>> {
        // default implementation (return empty)
        Err(anyhow::anyhow!("not implemented"))
    }
    fn cancel(&self) -> bool;
    fn is_canceled(&self) -> bool;
    fn runner_settings_proto(&self) -> String;
    fn job_args_proto(&self) -> String;
    fn result_output_proto(&self) -> Option<String>;
    fn output_type(&self) -> crate::jobworkerp::data::StreamingOutputType {
        crate::jobworkerp::data::StreamingOutputType::NonStreaming
    }
    fn settings_schema(&self) -> String {
        let schema = schemars::schema_for!(crate::jobworkerp::data::Empty);
        match serde_json::to_string(&schema) {
            Ok(s) => s,
            Err(e) => {
                tracing::error!("error in settings_schema: {:?}", e);
                "".to_string()
            }
        }
    }
    fn arguments_schema(&self) -> String {
        let schema = schemars::schema_for!(crate::jobworkerp::data::Empty);
        match serde_json::to_string(&schema) {
            Ok(s) => s,
            Err(e) => {
                tracing::error!("error in arguments_schema: {:?}", e);
                "".to_string()
            }
        }
    }
    fn output_json_schema(&self) -> Option<String> {
        None
    }
}

/// Multi-method PluginRunner trait (new plugins)
///
/// This trait is for new plugins that support multiple methods via method_proto_map().
/// Use this for plugins that need to expose multiple callable methods.
pub trait MultiMethodPluginRunner: Send + Sync {
    fn name(&self) -> String;
    fn description(&self) -> String;
    fn load(&mut self, settings: Vec<u8>) -> Result<()>;
    /// Execute with optional method selection
    ///
    /// # Arguments
    /// * `args` - Protobuf binary arguments
    /// * `metadata` - Job metadata
    /// * `using` - Optional method name for multi-method plugins
    fn run(
        &mut self,
        args: Vec<u8>,
        metadata: HashMap<String, String>,
        using: Option<&str>,
    ) -> (Result<Vec<u8>>, HashMap<String, String>);
    /// Begin streaming execution with optional method selection
    ///
    /// # Arguments
    /// * `arg` - Protobuf binary arguments
    /// * `metadata` - Job metadata
    /// * `using` - Optional method name for multi-method plugins
    fn begin_stream(
        &mut self,
        arg: Vec<u8>,
        metadata: HashMap<String, String>,
        using: Option<&str>,
    ) -> Result<()> {
        // default implementation (return empty)
        let (_, _, _) = (arg, metadata, using);
        Err(anyhow::anyhow!("not implemented"))
    }
    // receive stream generated by run_stream()
    fn receive_stream(&mut self) -> Result<Option<Vec<u8>>> {
        // default implementation (return empty)
        Err(anyhow::anyhow!("not implemented"))
    }
    fn cancel(&mut self) -> bool;
    fn is_canceled(&self) -> bool;
    fn runner_settings_proto(&self) -> String;

    /// Key: method name, Value: MethodSchema (input and output schemas)
    fn method_proto_map(&self) -> HashMap<String, crate::jobworkerp::data::MethodSchema>;

    /// Optional: Provide custom JSON schemas
    /// If None, automatic conversion from method_proto_map() will be used
    fn method_json_schema_map(
        &self,
    ) -> Option<HashMap<String, crate::jobworkerp::data::MethodJsonSchema>> {
        None
    }
    fn settings_schema(&self) -> String;

    /// Collect streaming output into a single result
    ///
    /// Default implementation: keeps only the last data chunk
    /// (protobuf binary concatenation produces invalid data)
    /// Plugins should override this for custom collection logic (e.g., merging proto messages)
    fn collect_stream(
        &self,
        stream: futures::stream::BoxStream<'static, crate::jobworkerp::data::ResultOutputItem>,
    ) -> CollectStreamFuture {
        use crate::jobworkerp::data::result_output_item;
        use futures::StreamExt;

        Box::pin(async move {
            let mut last_data: Option<Vec<u8>> = None;
            let mut metadata = HashMap::new();
            let mut stream = stream;

            while let Some(item) = stream.next().await {
                match item.item {
                    Some(result_output_item::Item::Data(data)) => {
                        last_data = Some(data);
                    }
                    Some(result_output_item::Item::FinalCollected(data)) => {
                        last_data = Some(data);
                    }
                    Some(result_output_item::Item::End(trailer)) => {
                        metadata = trailer.metadata;
                        break;
                    }
                    None => {}
                }
            }
            Ok((last_data.unwrap_or_default(), metadata))
        })
    }
}

/// Macro to convert a Rust type to a JSON schema string
#[macro_export]
macro_rules! schema_to_json_string {
    ($type:ty, $method_name:expr) => {{
        let schema = schemars::schema_for!($type);
        match serde_json::to_string(&schema) {
            Ok(s) => s,
            Err(e) => {
                tracing::error!("error in {}: {:?}", $method_name, e);
                "".to_string()
            }
        }
    }};
}

/// Macro to convert a Rust type to an Option<String> JSON schema
#[macro_export]
macro_rules! schema_to_json_string_option {
    ($type:ty, $method_name:expr) => {{
        let schema = schemars::schema_for!($type);
        match serde_json::to_string(&schema) {
            Ok(s) => Some(s),
            Err(e) => {
                tracing::error!("error in {}: {:?}", $method_name, e);
                None
            }
        }
    }};
}
